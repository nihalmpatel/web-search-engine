MIME types (IANA media types) - HTTP | MDN Skip to main content Select language Skip to search Technologies‚ñº Technologies Overview HTML CSS JavaScript Graphics HTTP APIs / DOM Browser Extensions MathML References & Guides‚ñº Learn web development Tutorials References Developer Guides Accessibility Game development ...more docs Feedback‚ñº Send Feedback Get Firefox help üåê Get web development help üåê Join the MDN community Report a content problem üåê Report an issue üåê Search MDN MIME types (IANA media types) Web technology for developers HTTP Basics of HTTP MIME types (IANA media types) English‚ñº ÿπÿ±ÿ®Ÿä Espa√±ol Fran√ßais Êó•Êú¨Ë™û ÌïúÍµ≠Ïñ¥ Portugu√™s (do¬†Brasil) –†—É—Å—Å–∫–∏–π –£–∫—Ä–∞—ó–Ω—Å—å–∫–∞ ‰∏≠Êñá (ÁÆÄ‰Ωì) Add a translation On this Page Structure of a MIME type Important MIME types for Web developers Importance of setting the correct MIME type MIME sniffing Other methods of conveying document type See also A media type (also known as a Multipurpose Internet Mail Extensions or MIME type) is a standard that indicates the nature and format of a document, file, or assortment of bytes. It is defined and standardized in IETF's RFC 6838. The Internet Assigned Numbers Authority (IANA) is responsible for all official MIME types, and you can find the most up-to-date and complete list at their Media Types page. Important: Browsers use the MIME type, not the file extension, to determine how to process a URL, so it's important that web servers send the correct MIME type in the response's Content-Type header. If this is not correctly configured, browsers are likely to misinterpret the contents of files and sites will not work correctly, and downloaded files may be mishandled. Structure of a MIME type The simplest MIME type consists of a type and a subtype; these are each strings which, when concatenated with a slash (/) between them, comprise a MIME type. No whitespace is allowed in a MIME type: type/subtype The type represents the general category into which the data type falls, such as video or text. The subtype identifies the exact kind of data of the specified type the MIME type represents. For example, for the MIME type text, the subtype might be plain (plain text), html (HTML source code), or calendar (for iCalendar/.ics) files. Each type has its own set of possible subtypes, and a MIME type always has both a type and a subtype, never just one or the other. An optional parameter can be added to provide additional details: type/subtype;parameter=value For example, for any MIME type whose main type is text, the optional charset parameter can be used to specify the character set used for the characters in the data. If no charset is specified, the default is ASCII (US-ASCII) unless overridden by the user agent's settings. To specify a UTF-8 text file, the MIME type text/plain;charset=UTF-8 is used. MIME types are case-insensitive but are traditionally written in lowercase, with the exception of parameter values, whose case may or may not have specific meaning. Types There are two classes of type: discrete and multipart. Discrete types are types which represent a single file or medium, such as a single text or music file, or a single video. A multipart type is one which represents a document that's comprised of multiple component parts, each of which may have its own individual MIME type; or, a multipart type may encapsulate multiple files being sent together in one transaction. For example, multipart MIME types are used when attaching multiple files to an email. Discrete types The discrete types currently registered with the IANA are: application List at IANA Any kind of binary data that doesn't fall explicitly into one of the other types; either data that will be executed or interpreted in some way or binary data that requires a specific application or category of application to use. Generic binary data (or binary data whose true type is unknown) is application/octet-stream. Other common examples include application/pdf, application/pkcs8, and application/zip. audio List at IANA Audio or music data. Examples include audio/mpeg, audio/vorbis. example Reserved for use as a placeholder in examples showing how to use MIME types. These should never be used outside of sample code listings and documentation. example can also be used as a subtype; for instance, in an example related to working with audio on the web, the MIME type audio/example can be used to indicate that the type is a placeholder and should be replaced with an appropriate one when using the code in the real world. font List at IANA Font/typeface data. Common examples include font/woff, font/ttf, and font/otf. image List at IANA Image or graphical data including both bitmap and vector still images as well as animated versions of still image formats such as animated GIF or APNG. Common examples are image/jpeg, image/png, and image/svg+xml. model List at IANA Model data for a 3D object or scene. Examples include model/3mf and model/vml. text List at IANA Text-only data including any human-readable content, source code, or textual data such as comma-separated value (CSV) formatted data. Examples include text/plain, text/csv, and text/html. video List at IANA Video data or files, such as MP4 movies ( video/mp4). For text documents without a specific subtype, text/plain should be used. Similarly, for binary documents without a specific or known subtype, application/octet-stream should be used. Multipart types Multipart types indicate a category of document broken into pieces, often with different MIME types; they can also be used ‚Äî especially in email scenarios ‚Äî to represent multiple, separate files which are all part of the same transaction. They represent a composite document. With the exception of multipart/form-data, used in the¬†POST method of HTML Forms, and multipart/byteranges, used with 206 Partial Content to send part of a document, HTTP doesn't handle multipart documents in a special way: the message is transmitted to the browser (which will likely show a "Save As" window if it doesn't know how to display the document). There are two multipart types: message List at IANA A message that encapsulates other messages. This can be used, for instance, to represent an email that includes a forwarded message as part of its data, or to allow sending very large messages in chunks as if it were multiple messages. Examples include message/rfc822 (for forwarded or replied-to message quoting) and message/partial to allow breaking a large message into smaller ones automatically to be reassembled by the recipient. multipart List at IANA Data that is comprised of multiple components which may individually have different MIME types. Examples include multipart/form-data (for data produced using the FormData API) and multipart/byteranges (defined in RFC 7233: 5.4.1 and used with HTTP's 206 "Partial Content" response returned when the fetched data is only part of the content, such as is delivered using the Range header). Important MIME types for Web developers application/octet-stream This is the default for binary files. As it means unknown binary file, browsers usually don't execute it, or even ask if it should be executed. They treat it as if the Content-Disposition header was set to attachment, and propose a "Save As" dialog. text/plain This is the default for textual files. Even if it really means "unknown textual file," browsers assume they can display it. Note that text/plain does not mean "any kind of textual data." If they expect a specific kind of textual data, they will likely not consider it a match. Specifically if they download a text/plain file from a <link> element declaring a CSS file, they will not recognize it as a valid CSS file if presented with text/plain. The CSS mime type text/css must be used. text/css CSS files used to style a Web page must be sent with text/css. If a server doesn't recognize the .css suffix for CSS files, it may send them with text/plain or application/octet-stream MIME types. If so, they won't be recognized as CSS by most browsers and will be ignored. text/html All HTML content should be served with this type. Alternative MIME types for XHTML (like application/xhtml+xml) are mostly useless nowadays. Note: Use application/xml or application/xhtml+xml if you want XML‚Äôs strict parsing rules, <![CDATA[‚Ä¶]]> sections, or elements that aren't from HTML/SVG/MathML namespaces. text/javascript Per the HTML specification, JavaScript files should always be served using the MIME type text/javascript. No other values are considered valid, and using any of those may result in scripts that do not load or run. For historical reasons, the MIME Sniffing Standard (the definition of how browsers should interpret media types and figure out what to do with content that doesn't have a valid one) allows JavaScript to be served using any MIME type that essentially matches any of the following: application/javascript application/ecmascript application/x-ecmascript¬† application/x-javascript¬† text/javascript text/ecmascript text/javascript1.0¬† text/javascript1.1¬† text/javascript1.2¬† text/javascript1.3¬† text/javascript1.4¬† text/javascript1.5¬† text/jscript¬† text/livescript¬† text/x-ecmascript¬† text/x-javascript¬† Note: Even though any given user agent may support any or all of these, you should only use text/javascript. It's the only MIME type guaranteed to work now and into the future. Some content you find may have a charset parameter at the end of the text/javascript media type, to specify the character set used to represent the code's content. This is not valid, and in most cases will result in a script not being loaded. Image types Files whose MIME type is image contain image data. The subtype specifies which specific image file format the data represents. Only a few image types are used commonly enough to be considered safe for use on web pages: Abbreviation File format MIME type File extension(s) Browser compatibility APNG Animated Portable Network Graphics image/apng .apng Chrome, Edge, Firefox, Opera, Safari BMP Bitmap file image/bmp .bmp Chrome, Edge, Firefox, Internet Explorer, Opera, Safari GIF Graphics Interchange Format image/gif .gif Chrome, Edge, Firefox, Internet Explorer, Opera, Safari ICO Microsoft Icon image/x-icon .ico, .cur Chrome, Edge, Firefox, Internet Explorer, Opera, Safari JPEG Joint Photographic Expert Group image image/jpeg .jpg, .jpeg, .jfif, .pjpeg, .pjp Chrome, Edge, Firefox, Internet Explorer, Opera, Safari PNG Portable Network Graphics image/png .png Chrome, Edge, Firefox, Internet Explorer, Opera, Safari SVG Scalable Vector Graphics image/svg+xml .svg Chrome, Edge, Firefox, Internet Explorer, Opera, Safari TIFF Tagged Image File Format image/tiff .tif, .tiff None built-in; add-ons required WebP Web Picture format image/webp .webp Chrome, Edge, Firefox, Opera The abbreviation for each format links to a longer description of the format, its capabilities, and detailed browser compatibility information; including which versions introduced support and specific special features that may have been introduced later. Audio and video types As is the case for images, HTML doesn't mandate that web browsers support any specific file and codec types for the <audio> and <video> elements, so it's important to consider your target audience and the range of browsers (and versions of those browsers) they may be using when choosing the file type and codecs to use for media. Our media container formats guide provides a list of the file types that are commonly supported by web browsers, including information about what their special use cases may be, any drawbacks they have, and compatibility information, along with other details. The audio codec and video codec guides list the various codecs that web browsers often support, providing compatibility details along with technical information such as how many audio channels they support, what sort of compression is used, and what bit rates and so forth they're useful at. The codecs used by WebRTC guide expands upon this by specifically covering the codecs supported by the major web browsers, so you can choose the codecs that best cover the range of browsers you wish to support. As for MIME types of audio or video files, they typically specify the container format (file type). The optional codecs parameter can be added to the MIME type to further specify which codecs to use and what options were used to encode the media, such as codec profile, level, or other such information. The most commonly used MIME types used for web content are listed below. This isn't a complete list of all the types that may be available, however. See the media container formats guide for that. MIME type Audio or video type audio/wave audio/wav audio/x-wav audio/x-pn-wav An audio file in the WAVE container format. The PCM audio codec (WAVE codec "1") is often supported, but other codecs have limited support (if any). audio/webm An audio file in the WebM container format. Vorbis and Opus are the codecs officially supported by the WebM specification. video/webm A video file, possibly with audio, in the WebM container format. VP8 and VP9 are the most common video codecs; Vorbis and Opus the most common audio codecs. audio/ogg An audio file in the Ogg container format. Vorbis is the most common audio codec used in such a container; however, Opus is now supported by Ogg as well. video/ogg A video file, possibly with audio, in the Ogg container format. Theora is the usual video codec used within it; Vorbis is the usual audio codec, although Opus is becoming more common. application/ogg An audio or video file using the Ogg container format. Theora is the usual video codec used within it; Vorbis is the usual audio codec. multipart/form-data The multipart/form-data type can be used when sending the values of a completed HTML Form from browser to server. As a multipart document format, it consists of different parts, delimited by a boundary (a string starting with a double dash --). Each part is its own entity with its own HTTP headers, Content-Disposition, and Content-Type for file uploading fields. Content-Type: multipart/form-data; boundary=aBoundaryString
(other headers associated with the multipart document as a whole)

--aBoundaryString
Content-Disposition: form-data; name="myFile"; filename="img.jpg"
Content-Type: image/jpeg

(data)
--aBoundaryString
Content-Disposition: form-data; name="myField"

(data)
--aBoundaryString
(more subparts)
--aBoundaryString--

 The following <form>: <form action="http://localhost:8000/" method="post" enctype="multipart/form-data">
  <label>Name: <input name="myTextField" value="Test"></label>
  <label><input type="checkbox" name="myCheckBox"> Check</label>
  <label>Upload file: <input type="file" name="myFile" value="test.txt"></label>
  <button>Send the file</button>
</form> will send this message: POST / HTTP/1.1
Host: localhost:8000
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.9; rv:50.0) Gecko/20100101 Firefox/50.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: keep-alive
Upgrade-Insecure-Requests: 1
Content-Type: multipart/form-data; boundary=---------------------------8721656041911415653955004498
Content-Length: 465

-----------------------------8721656041911415653955004498
Content-Disposition: form-data; name="myTextField"

Test
-----------------------------8721656041911415653955004498
Content-Disposition: form-data; name="myCheckBox"

on
-----------------------------8721656041911415653955004498
Content-Disposition: form-data; name="myFile"; filename="test.txt"
Content-Type: text/plain

Simple file.
-----------------------------8721656041911415653955004498--

 multipart/byteranges The multipart/byteranges MIME type is used to send partial responses to the browser. When the 206 Partial Content status code is sent, this MIME type indicates that the document is composed of several parts, one for each of the requested ranges. Like other multipart types, the Content-Type uses a boundary to separate the pieces. Each piece has a Content-Type header with its actual type and a Content-Range of the range it represents. HTTP/1.1 206 Partial Content
Accept-Ranges: bytes
Content-Type: multipart/byteranges; boundary=3d6b6a416f9b5
Content-Length: 385

--3d6b6a416f9b5
Content-Type: text/html
Content-Range: bytes 100-200/1270

eta http-equiv="Content-type" content="text/html; charset=utf-8" />
    <meta name="vieport" content
--3d6b6a416f9b5
Content-Type: text/html
Content-Range: bytes 300-400/1270

-color: #f0f0f2;
        margin: 0;
        padding: 0;
        font-family: "Open Sans", "Helvetica
--3d6b6a416f9b5-- Importance of setting the correct MIME type Most web servers send unrecognized resources as the application/octet-stream MIME type. For security reasons, most browsers do not allow setting a custom default action for such resources, forcing the user to save it to disk to use it. Some common incorrect server configurations: RAR-compressed files. In this case, the ideal would be the true type of the original files; this is often impossible as .RAR files can hold several resources of different types. In this case, configure the server to send application/x-rar-compressed. Audio and video. Only resources with the correct MIME Type will be played in <video> or <audio> elements. Be sure to specify the correct media type for audio and video. Proprietary file types. Avoid using application/octet-stream as most browsers do not allow defining a default behavior (like "Open in Word") for this generic MIME type. A specific type like application/vnd.mspowerpoint lets users open such files automatically in the presentation software of their choice. MIME sniffing In the absence of a MIME type, or in certain cases where browsers believe they are incorrect, browsers may perform MIME sniffing ‚Äî guessing the correct MIME type by looking at the bytes of the resource. Each browser performs MIME sniffing differently and under different circumstances. (For example, Safari will look at the file extension in the URL if the sent MIME type is unsuitable.) There are security concerns as some MIME types represent executable content. Servers can prevent MIME sniffing by sending the X-Content-Type-Options header. Other methods of conveying document type MIME types are not the only way to convey document type information: Filename suffixes are sometimes used, especially on Microsoft Windows. Not all operating systems consider these suffixes meaningful (such as Linux and MacOS), and there is no guarantee they are correct. Magic numbers. The syntax of different formats allows file-type inference by looking at their byte structure. For example, GIF files start with the 47 49 46 38 39 hexadecimal value (GIF89), and PNG files with 89 50 4E 47 (.PNG). Not all file types have magic numbers, so this is not 100% reliable either. See also Web media technologies Guide to media types used on the web Properly configuring server MIME types Metadata Last modified: Nov 3, 2019, by MDN contributors Related Topics HTTP Guides: Resources and URIs Identifying resources on the Web Data URIs Introduction to MIME Types Complete list of MIME Types Choosing between www and non-www URLs HTTP guide Basics of HTTP Overview of HTTP Evolution of HTTP HTTP Messages A typical HTTP session Connection management in HTTP/1.x Protocol upgrade mechanism HTTP security Content Security Policy (CSP) HTTP Public Key Pinning (HPKP) HTTP Strict Transport Security (HSTS) Cookie security X-Content-Type-Options X-Frame-Options X-XSS-Protection Mozilla web security guidelines Mozilla Observatory HTTP access control (CORS) HTTP authentication HTTP caching HTTP compression HTTP conditional requests HTTP content negotiation HTTP cookies HTTP range requests HTTP redirects HTTP specifications Feature policy References: HTTP headers Accept Accept-CH Accept-CH-Lifetime Accept-Charset Accept-Encoding Accept-Language Accept-Patch Accept-Ranges Access-Control-Allow-Credentials Access-Control-Allow-Headers Access-Control-Allow-Methods Access-Control-Allow-Origin Access-Control-Expose-Headers Access-Control-Max-Age Access-Control-Request-Headers Access-Control-Request-Method Age Allow Alt-Svc Authorization Cache-Control Clear-Site-Data Connection Content-Disposition Content-Encoding Content-Language Content-Length Content-Location Content-Range Content-Security-Policy Content-Security-Policy-Report-Only Content-Type Cookie Cookie2 Cross-Origin-Resource-Policy DNT DPR Date Device-Memory Digest ETag Early-Data Expect Expect-CT Expires Feature-Policy Forwarded From Host If-Match If-Modified-Since If-None-Match If-Range If-Unmodified-Since Index Keep-Alive Large-Allocation Last-Modified Link Location Origin Pragma Proxy-Authenticate Proxy-Authorization Public-Key-Pins Public-Key-Pins-Report-Only Range Referer Referrer-Policy Retry-After Save-Data Sec-WebSocket-Accept Server Server-Timing Set-Cookie Set-Cookie2 SourceMap Strict-Transport-Security TE Timing-Allow-Origin Tk Trailer Transfer-Encoding Upgrade-Insecure-Requests User-Agent Vary Via WWW-Authenticate Want-Digest Warning X-Content-Type-Options X-DNS-Prefetch-Control X-Forwarded-For X-Forwarded-Host X-Forwarded-Proto X-Frame-Options X-XSS-Protection HTTP request methods CONNECT DELETE GET HEAD OPTIONS PATCH POST PUT TRACE HTTP response status codes 100 Continue 101 Switching Protocols 103 Early Hints 200 OK 201 Created 202 Accepted 203 Non-Authoritative Information 204 No Content 205 Reset Content 206 Partial Content 300 Multiple Choices 301 Moved Permanently 302 Found 303 See Other 304 Not Modified 307 Temporary Redirect 308 Permanent Redirect 400 Bad Request 401 Unauthorized 402 Payment Required 403 Forbidden 404 Not Found 405 Method Not Allowed 406 Not Acceptable 407 Proxy Authentication Required 408 Request Timeout 409 Conflict 410 Gone 411 Length Required 412 Precondition Failed 413 Payload Too Large 414 URI Too Long 415 Unsupported Media Type 416 Range Not Satisfiable 417 Expectation Failed 418 I'm a teapot 422 Unprocessable Entity 425 Too Early 426 Upgrade Required 428 Precondition Required 429 Too Many Requests 431 Request Header Fields Too Large 451 Unavailable For Legal Reasons 500 Internal Server Error 501 Not Implemented 502 Bad Gateway 503 Service Unavailable 504 Gateway Timeout 505 HTTP Version Not Supported 506 Variant Also Negotiates 507 Insufficient Storage 508 Loop Detected 511 Network Authentication Required CSP directives CSP: base-uri CSP: block-all-mixed-content CSP: child-src CSP: connect-src CSP: default-src CSP: font-src CSP: form-action CSP: frame-ancestors CSP: frame-src CSP: img-src CSP: manifest-src CSP: media-src CSP: navigate-to CSP: object-src CSP: plugin-types CSP: prefetch-src CSP: referrer CSP: report-to CSP: report-uri CSP: require-sri-for CSP: sandbox CSP: script-src CSP: script-src-attr CSP: script-src-elem CSP: style-src CSP: style-src-attr CSP: style-src-elem CSP: trusted-types CSP: upgrade-insecure-requests CSP: worker-src CORS errors Reason: CORS disabled Reason: CORS header 'Access-Control-Allow-Origin' does not match 'xyz' Reason: CORS header 'Access-Control-Allow-Origin' missing Reason: CORS header ‚ÄòOrigin‚Äô cannot be added Reason: CORS preflight channel did not succeed Reason: CORS request did not succeed Reason: CORS request external redirect not allowed Reason: CORS request not HTTP Reason: Credential is not supported if the CORS header ‚ÄòAccess-Control-Allow-Origin‚Äô is ‚Äò*‚Äô Reason: Did not find method in CORS header ‚ÄòAccess-Control-Allow-Methods‚Äô Reason: Multiple CORS header 'Access-Control-Allow-Origin' not allowed Reason: expected ‚Äòtrue‚Äô in CORS header ‚ÄòAccess-Control-Allow-Credentials‚Äô Reason: invalid token ‚Äòxyz‚Äô in CORS header ‚ÄòAccess-Control-Allow-Headers‚Äô Reason: invalid token ‚Äòxyz‚Äô in CORS header ‚ÄòAccess-Control-Allow-Methods‚Äô Reason: missing token ‚Äòxyz‚Äô in CORS header ‚ÄòAccess-Control-Allow-Headers‚Äô from CORS preflight channel Feature-Policy directives Feature-Policy: accelerometer Feature-Policy: ambient-light-sensor Feature-Policy: autoplay Feature-Policy: camera Feature-Policy: display-capture Feature-Policy: document-domain Feature-Policy: encrypted-media Feature-Policy: fullscreen Feature-Policy: geolocation Feature-Policy: gyroscope Feature-Policy: layout-animations Feature-Policy: legacy-image-formats Feature-Policy: magnetometer Feature-Policy: microphone Feature-Policy: midi Feature-Policy: oversized-images Feature-Policy: payment Feature-Policy: picture-in-picture Feature-Policy: speaker Feature-Policy: sync-xhr Feature-Policy: unoptimized-images Feature-Policy: unsized-media Feature-Policy: usb Feature-Policy: vibrate Feature-Policy: vr Feature-Policy: wake-lock Feature-Policy: webauthn Feature-Policy: xr Learn the best of web development Get the latest and greatest from MDN delivered straight to your inbox. The newsletter is offered in English only at the moment. E-mail I‚Äôm okay with Mozilla handling my info as explained in this Privacy Policy. Sign up now Hide Newsletter Sign-up MDN Web Docs MDN Web Technologies Learn Web Development About MDN Feedback Mozilla Mozilla About Contact Us Firefox Terms Privacy Cookies ¬© 2005- 2019 Mozilla and individual contributors. Content is available under these licenses.